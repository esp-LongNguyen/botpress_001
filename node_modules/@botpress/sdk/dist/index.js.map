{
  "version": 3,
  "sources": ["../src/index.ts", "../src/bot/client.ts", "../src/const.ts", "../src/serve.ts", "../src/log.ts", "../src/bot/server.ts", "../src/bot/context.ts", "../src/bot/implementation.ts", "../src/integration/client.ts", "../src/integration/error.ts", "../src/integration/context.ts", "../src/integration/definition.ts", "../src/integration/schema.ts", "../src/integration/server.ts", "../src/integration/logger.ts", "../src/integration/implementation.ts", "../src/message.ts"],
  "sourcesContent": ["import { BotClient } from './bot'\nimport { IntegrationClient } from './integration'\n\nexport * as messages from './message'\nexport const clients = { IntegrationClient, BotClient }\n\nexport * from './const'\nexport * from './serve'\n\nexport {\n  IntegrationDefinition,\n  IntegrationDefinitionProps,\n  IntegrationImplementation as Integration,\n  IntegrationImplementationProps as IntegrationProps,\n  IntegrationContext,\n  IntegrationOperation,\n  ActionDefinitions,\n  ChannelDefinitions,\n  EventDefinitions,\n  AckFunction,\n} from './integration'\nexport { Bot, BotContext, BotOperation, IntegrationInstance } from './bot'\n", "import axiosGlobal, { Axios as AxiosInstance } from 'axios'\nimport type { Merge, Except } from 'type-fest'\nimport { botIdHeader, operationHeader, configurationHeader, typeHeader } from '../const'\nimport type { BotContext, BotOperation } from './context'\nimport type { RegisterBotPayload, UnregisterBotPayload, EventReceivedBotPayload } from './implementation'\n\ntype Props<T = any> = Merge<\n  Except<BotContext, 'operation'>,\n  {\n    url: string\n    data: T\n  }\n>\n\n/**\n * @description Meant to query your bot server directly (e.g. without going through the Botpress API)\n */\nexport class BotClient {\n  private axios: AxiosInstance\n\n  public constructor(axiosInstance?: AxiosInstance) {\n    this.axios = axiosInstance ?? axiosGlobal.create({ timeout: 5000 })\n  }\n\n  public register = (props: Props<RegisterBotPayload>) => request('register', props, this.axios)\n  public unregister = (props: Props<UnregisterBotPayload>) => request('unregister', props, this.axios)\n  public eventReceived = (props: Props<EventReceivedBotPayload>) => request('event_received', props, this.axios)\n}\n\nexport function formatBotHeaders(ctx: BotContext) {\n  return {\n    [typeHeader]: ctx.type,\n    [botIdHeader]: ctx.botId,\n    [operationHeader]: ctx.operation,\n    [configurationHeader]: Buffer.from(\n      typeof ctx.configuration === 'string' ? ctx.configuration : JSON.stringify(ctx.configuration),\n      'utf-8'\n    ).toString('base64'),\n  }\n}\n\nasync function request<O = any>(operation: BotOperation, { url, data, ...ctx }: Props, axios: AxiosInstance) {\n  const response = await axios.post<O>(url, data, {\n    headers: formatBotHeaders({\n      ...ctx,\n      operation,\n    }),\n  })\n\n  return response.data\n}\n", "export const botIdHeader = 'x-bot-id'\nexport const botUserIdHeader = 'x-bot-user-id'\nexport const integrationIdHeader = 'x-integration-id'\nexport const webhookIdHeader = 'x-webhook-id'\n\nexport const configurationHeader = 'x-bp-configuration'\nexport const operationHeader = 'x-bp-operation'\nexport const typeHeader = 'x-bp-type'\n", "import { createServer, IncomingMessage, Server } from 'node:http'\nimport { log } from './log'\n\nexport type Request = {\n  body?: string\n  path: string\n  query: string\n  method: string\n  headers: { [key: string]: string | undefined }\n}\n\nexport type Response = {\n  body?: string\n  headers?: { [key: string]: string }\n  status?: number\n}\n\nexport type Handler = (req: Request) => Promise<Response | void>\n\nexport async function serve(\n  handler: Handler,\n  port: number = 8072,\n  callback: (port: number) => void = defaultCallback\n): Promise<Server> {\n  /* eslint-disable @typescript-eslint/no-misused-promises */\n  const server = createServer(async (req, res) => {\n    try {\n      const request = await mapIncomingMessageToRequest(req)\n      const response = await handler(request)\n      res.writeHead(response?.status ?? 200, response?.headers ?? {}).end(response?.body ?? '{}')\n    } catch (e: any) {\n      log.error('Error while handling request', { error: e?.message ?? 'Internal error occured' })\n      res.writeHead(500).end(JSON.stringify({ error: e?.message ?? 'Internal error occured' }))\n    }\n  })\n\n  server.listen(port, () => callback(port))\n  return server\n}\n\nasync function mapIncomingMessageToRequest(incoming: IncomingMessage): Promise<Request> {\n  const body = await readBody(incoming)\n  const headers = {} as Request['headers']\n\n  for (let i = 0; i < incoming.rawHeaders.length; i += 2) {\n    const key = incoming.rawHeaders[i]!.toLowerCase()\n    const value = incoming.rawHeaders[i + 1]!\n    headers[key] = value\n  }\n\n  const url = new URL(\n    incoming.url ?? '',\n    incoming.headers.host ? `http://${incoming.headers.host}` : 'http://botpress.cloud'\n  )\n\n  return {\n    body,\n    path: url.pathname,\n    query: trimPrefix(url.search, '?'),\n    headers,\n    method: incoming.method?.toUpperCase() ?? 'GET',\n  }\n}\n\nfunction trimPrefix(value: string, prefix: string) {\n  return value.indexOf(prefix) === 0 ? value.slice(prefix.length) : value\n}\n\nasync function readBody(incoming: IncomingMessage) {\n  return new Promise<string | undefined>((resolve, reject) => {\n    if (incoming.method !== 'POST' && incoming.method !== 'PUT' && incoming.method !== 'PATCH') {\n      return resolve(undefined)\n    }\n\n    let body = ''\n\n    incoming.on('data', (chunk) => (body += chunk.toString()))\n    incoming.on('error', (e) => reject(e))\n    incoming.on('end', () => resolve(body))\n  })\n}\n\nfunction defaultCallback(port: number) {\n  log.info(`Listening on port ${port}`)\n}\n", "export type Logger = {\n  debug(message: string, metadata?: any): void\n  info(message: string, metadata?: any): void\n  warn(message: string, metadata?: any): void\n  error(message: string, metadata?: any): void\n}\nexport const log: Logger = console\n", "import { Client } from '@botpress/client'\nimport { botIdHeader, configurationHeader, operationHeader, typeHeader } from '../const'\nimport { log } from '../log'\nimport type { Handler, Request, Response } from '../serve'\nimport { BotContext, botOperationSchema } from './context'\nimport type { EventReceivedBotPayload } from './implementation'\nimport type { BotState } from './state'\n\ntype OperationHandlerProps = {\n  botState: BotState\n  ctx: BotContext\n  client: Client\n  req: Request\n}\n\nexport const createBotHandler =\n  (botState: BotState): Handler =>\n  async (req: Request): Promise<Response> => {\n    const ctx = extractContext(req.headers)\n\n    if (ctx.operation !== 'ping') {\n      log.info(`Received ${ctx.operation} operation for bot ${ctx.botId} of type ${ctx.type}`)\n    }\n\n    const client = new Client({ botId: ctx.botId })\n\n    const props: OperationHandlerProps = {\n      req,\n      botState,\n      ctx,\n      client,\n    }\n\n    switch (ctx.operation) {\n      case 'event_received':\n        await onEventReceived(props)\n        break\n      case 'register':\n        await onRegister(props)\n        break\n      case 'unregister':\n        await onUnregister(props)\n        break\n      case 'ping':\n        await onPing(props)\n        break\n      default:\n        throw new Error(`Unknown operation ${ctx.operation}`)\n    }\n\n    return { status: 200 }\n  }\n\nfunction extractContext(headers: Record<string, string | undefined>): BotContext {\n  const botId = headers[botIdHeader]\n  const base64Configuration = headers[configurationHeader]\n  const type = headers[typeHeader]\n  const operation = botOperationSchema.parse(headers[operationHeader])\n\n  if (!botId) {\n    throw new Error('Missing bot headers')\n  }\n\n  if (!type) {\n    throw new Error('Missing type headers')\n  }\n\n  if (!base64Configuration) {\n    throw new Error('Missing configuration headers')\n  }\n\n  if (!operation) {\n    throw new Error('Missing operation headers')\n  }\n\n  return {\n    botId,\n    operation,\n    type,\n    configuration: base64Configuration ? JSON.parse(Buffer.from(base64Configuration, 'base64').toString('utf-8')) : {},\n  }\n}\n\nasync function onEventReceived({ botState, ctx, req }: OperationHandlerProps) {\n  log.debug(`Received event ${ctx.type}`)\n\n  const client = new Client({ botId: ctx.botId })\n\n  const body = parseBody<EventReceivedBotPayload>(req)\n\n  switch (ctx.type) {\n    case 'message_created':\n      await Promise.all(\n        botState.messageHandlers.map((handler) =>\n          handler({\n            client,\n            user: body.event.payload.user as any,\n            conversation: body.event.payload.conversation as any,\n            message: body.event.payload.message as any,\n            event: body.event,\n            ctx,\n          })\n        )\n      )\n      break\n    case 'state_expired':\n      await Promise.all(\n        botState.stateExpiredHandlers.map((handler) =>\n          handler({\n            client,\n            state: body.event.payload.state as any,\n            ctx,\n          })\n        )\n      )\n      break\n    default:\n      await Promise.all(\n        botState.eventHandlers.map((handler) =>\n          handler({\n            client,\n            event: body.event,\n            ctx,\n          })\n        )\n      )\n  }\n}\n\n// TODO implement the ping operation once the signature is defined\nasync function onPing(_: OperationHandlerProps) {}\n\nasync function onRegister(_: OperationHandlerProps) {}\n\nasync function onUnregister(_: OperationHandlerProps) {}\n\nfunction parseBody<T>(req: Request): T {\n  if (!req.body) {\n    throw new Error('Missing body')\n  }\n\n  return JSON.parse(req.body)\n}\n", "import { z } from 'zod'\n\nexport const botOperationSchema = z.enum(['event_received', 'register', 'unregister', 'ping'])\n\nexport type BotOperation = z.infer<typeof botOperationSchema>\n\nexport type BotContext<Configuration = any, Type extends string = string> = {\n  botId: string\n  type: Type\n  operation: BotOperation\n  configuration: Configuration\n}\n", "import type { Bot as BotType, Event } from '@botpress/client'\nimport type { Server } from 'node:http'\nimport { serve } from '../serve'\nimport { createBotHandler } from './server'\nimport type { BotState, EventHandler, MessageHandler, StateExpiredHandler } from './state'\n\nexport type RegisterBotPayload = {\n  bot: BotType\n}\n\nexport type UnregisterBotPayload = {\n  bot: BotType\n}\n\nexport type EventReceivedBotPayload = {\n  event: Event\n}\n\nexport type BotDefinitionTag = {\n  title?: string\n  description?: string\n}\n\nexport type BotDefinitionStateType = 'conversation' | 'user' | 'bot'\nexport type BotDefinitionState = {\n  type: BotDefinitionStateType\n  schema: Record<string, any>\n  expiry?: number\n}\n\nexport type IntegrationInstance = {\n  id: string\n  enabled?: boolean\n  configuration?: { [key: string]: any }\n}\n\nexport type BotDefinitionRecurringEvent = {\n  type: string\n  payload: Record<string, any>\n  schedule: {\n    cron: string\n  }\n}\n\nexport type BotDefinitionEvent = {\n  schema: Record<string, any>\n}\n\nexport type BotDefinitionConfiguration = {\n  schema: Record<string, any>\n}\n\nexport type BotDefinitionUser = {\n  tags?: Record<string, BotDefinitionTag>\n}\n\nexport type BotDefinitionConversation = {\n  tags?: Record<string, BotDefinitionTag>\n}\n\nexport type BotDefinitionMessage = {\n  tags?: Record<string, BotDefinitionTag>\n}\n\nexport type BotDefinition = {\n  user?: BotDefinitionUser\n  conversation?: BotDefinitionConversation\n  message?: BotDefinitionMessage\n  states?: Record<string, BotDefinitionState>\n  integrations?: IntegrationInstance[]\n  configuration?: BotDefinitionConfiguration\n  events?: Record<string, BotDefinitionEvent>\n  recurringEvents?: Record<string, BotDefinitionRecurringEvent>\n}\n\nexport class Bot {\n  private _state: BotState = {\n    registerHandlers: [],\n    unregisterHandlers: [],\n    messageHandlers: [],\n    eventHandlers: [],\n    stateExpiredHandlers: [],\n  }\n\n  public readonly definition: BotDefinition\n\n  public constructor(def: BotDefinition = {}) {\n    this.definition = def\n  }\n\n  public message = (handler: MessageHandler): void => {\n    this._state.messageHandlers.push(handler)\n  }\n  public event = (handler: EventHandler): void => {\n    this._state.eventHandlers.push(handler)\n  }\n  public stateExpired = (handler: StateExpiredHandler): void => {\n    this._state.stateExpiredHandlers.push(handler)\n  }\n\n  public handler = createBotHandler(this._state)\n  public start = (port?: number): Promise<Server> => serve(this.handler, port)\n}\n", "import { Conversation, RuntimeError, Message, User } from '@botpress/client'\nimport axiosGlobal, { Axios as AxiosInstance } from 'axios'\nimport {\n  botIdHeader,\n  operationHeader,\n  integrationIdHeader,\n  configurationHeader,\n  botUserIdHeader,\n  webhookIdHeader,\n} from '../const'\nimport type { IntegrationContext, IntegrationOperation } from './context'\nimport { runtimeErrorSchema } from './error'\nimport type {\n  ActionPayload,\n  CreateConversationPayload,\n  CreateUserPayload,\n  MessagePayload,\n  RegisterPayload,\n  UnregisterPayload,\n  WebhookPayload,\n} from './implementation'\n\ntype Props<T = any> = {\n  url: string\n  data: T\n} & Omit<IntegrationContext, 'operation'>\n\n/**\n * @description Meant to query your integration server directly (e.g. without going through the Botpress API)\n */\nexport class IntegrationClient {\n  private axios: AxiosInstance\n\n  public constructor(axiosInstance?: AxiosInstance) {\n    this.axios = axiosInstance ?? axiosGlobal.create({ timeout: 5000 })\n  }\n\n  public actionTriggered = (props: Props<ActionPayload<string, any>>) => request('action_triggered', props, this.axios)\n  public messageCreated = (props: Props<MessagePayload<any, Message, Conversation, User>>) =>\n    request('message_created', props, this.axios)\n  public register = (props: Props<RegisterPayload>) => request('register', props, this.axios)\n  public unregister = (props: Props<UnregisterPayload>) => request('unregister', props, this.axios)\n  public webhookReceived = (props: Props<WebhookPayload>) => webhookRequest('webhook_received', props, this.axios)\n  public createUser = (props: Props<CreateUserPayload>) =>\n    request<{ user: { id: User['id'] } }>('create_user', props, this.axios)\n  public createConversation = (props: Props<CreateConversationPayload>) =>\n    request<{ conversation: { id: Conversation['id'] } }>('create_conversation', props, this.axios)\n}\n\nexport function formatIntegrationHeaders(ctx: IntegrationContext) {\n  return {\n    [botIdHeader]: ctx.botId,\n    [operationHeader]: ctx.operation,\n    [botUserIdHeader]: ctx.botUserId,\n    [integrationIdHeader]: ctx.integrationId,\n    [webhookIdHeader]: ctx.webhookId,\n    [configurationHeader]: Buffer.from(\n      typeof ctx.configuration === 'string' ? ctx.configuration : JSON.stringify(ctx.configuration),\n      'utf-8'\n    ).toString('base64'),\n  }\n}\n\nasync function webhookRequest(operation: IntegrationOperation, { url, data, ...ctx }: Props, axios: AxiosInstance) {\n  const response = await axios\n    .post<unknown>(url, data, {\n      headers: formatIntegrationHeaders({\n        ...ctx,\n        operation,\n      }),\n    })\n    .catch((e) => {\n      if (axiosGlobal.isAxiosError(e) && e.response?.status && e.response.status < 500) {\n        return e.response\n      }\n\n      throw e\n    })\n\n  return response\n}\n\nasync function request<O = any>(operation: IntegrationOperation, { url, data, ...ctx }: Props, axios: AxiosInstance) {\n  try {\n    const response = await axios.post<O>(url, data, {\n      headers: formatIntegrationHeaders({\n        ...ctx,\n        operation,\n      }),\n    })\n\n    return response\n  } catch (e) {\n    const runtimeErrorCode = new RuntimeError('').code\n    if (axiosGlobal.isAxiosError(e) && e.response?.status === runtimeErrorCode) {\n      const result = runtimeErrorSchema.safeParse(e.response.data)\n      if (result.success) {\n        throw new RuntimeError(result.data.message)\n      }\n    }\n    throw e\n  }\n}\n", "import { RuntimeError } from '@botpress/client'\nimport { z } from 'zod'\n\n// simply used to build the schema\nconst e = new RuntimeError('')\n\nexport const runtimeErrorSchema = z.object({\n  code: z.literal(e.code),\n  type: z.literal(e.type),\n  message: z.string(),\n})\n", "import { z } from 'zod'\n\nexport const integrationOperationSchema = z.enum([\n  'webhook_received',\n  'message_created',\n  'action_triggered',\n  'register',\n  'unregister',\n  'ping',\n  'create_user',\n  'create_conversation',\n])\n\nexport type IntegrationOperation = z.infer<typeof integrationOperationSchema>\n\nexport type IntegrationContext<Configuration = any> = {\n  botId: string\n  botUserId: string\n  integrationId: string\n  webhookId: string\n  operation: IntegrationOperation\n  configuration: Configuration\n}\n", "import { mapValues } from 'radash'\nimport { z } from 'zod'\n\nimport { SchemaDefinition, schemaDefinitionToJsonSchema } from './schema'\n\nconst nonEmptyDict = <V extends z.ZodTypeAny>(v: V) => {\n  const r = z.record(v)\n  return {\n    min: (n: number) =>\n      r.refine((obj) => Object.keys(obj).length >= n, { message: `At least ${n} item(s) must be defined` }),\n  }\n}\n\nexport const schemaSchema = z.object({}).passthrough()\n\nexport const configurationDefinitionSchema = z.object({\n  schema: schemaSchema,\n})\n\nexport const eventDefinitionSchema = z.object({\n  title: z.string().optional(),\n  description: z.string().optional(),\n  schema: schemaSchema,\n})\n\nexport const actionDefinitionSchema = z.object({\n  title: z.string().optional(),\n  description: z.string().optional(),\n  input: z.object({\n    schema: schemaSchema,\n  }),\n  output: z.object({\n    schema: schemaSchema,\n  }),\n})\n\nexport const messageDefinitionSchema = z.object({\n  schema: schemaSchema,\n})\n\nexport const tagDefinitionSchema = z.object({\n  title: z.string().optional(),\n  description: z.string().optional(),\n})\n\nexport const channelDefinitionSchema = z.object({\n  title: z.string().optional(),\n  description: z.string().optional(),\n  messages: nonEmptyDict(messageDefinitionSchema).min(1),\n  message: z\n    .object({\n      tags: z.record(tagDefinitionSchema),\n    })\n    .partial()\n    .optional(),\n  conversation: z\n    .object({\n      tags: z.record(tagDefinitionSchema),\n      creation: z.object({\n        enabled: z.boolean(),\n        requiredTags: z.array(z.string()),\n      }),\n    })\n    .partial()\n    .optional(),\n})\n\nexport const stateDefinitionSchema = z.object({\n  type: z.union([z.literal('integration'), z.literal('conversation'), z.literal('user')]),\n  schema: schemaSchema,\n})\n\nconst PUBLIC_VERSION = '0.2.0' as const\nconst PRIVATE_VERSION = '0.0.1' as const\n\nexport const integrationDefinitionSchema = z.object({\n  name: z.string(),\n  version: z.enum([PRIVATE_VERSION, PUBLIC_VERSION]),\n  title: z.string().optional(),\n  description: z.string().optional(),\n  icon: z.string().optional(),\n  readme: z.string().optional(),\n  configuration: configurationDefinitionSchema.optional(),\n  events: z.record(eventDefinitionSchema).optional(),\n  actions: z.record(actionDefinitionSchema).optional(),\n  channels: z.record(channelDefinitionSchema).optional(),\n  states: z.record(stateDefinitionSchema).optional(),\n  user: z\n    .object({\n      tags: z.record(tagDefinitionSchema),\n      creation: z.object({\n        enabled: z.boolean(),\n        requiredTags: z.array(z.string()),\n      }),\n    })\n    .partial()\n    .optional(),\n  secrets: z.array(z.string()).optional(),\n})\n\nexport type ConfigurationDefinition = z.infer<typeof configurationDefinitionSchema>\nexport type EventDefinition = z.infer<typeof eventDefinitionSchema>\nexport type ChannelDefinition = z.infer<typeof channelDefinitionSchema>\nexport type ActionDefinition = z.infer<typeof actionDefinitionSchema>\nexport type MessageDefinition = z.infer<typeof messageDefinitionSchema>\nexport type StateDefinition = z.infer<typeof stateDefinitionSchema>\n\ntype IntegrationDefinitionInput = z.input<typeof integrationDefinitionSchema>\ntype IntegrationDefinitionOutput = z.infer<typeof integrationDefinitionSchema>\n\ntype AnyZodObject = z.ZodObject<any>\ntype Merge<A extends object, B extends object> = Omit<A, keyof B> & B\ntype Cast<T, U> = T extends U ? T : U\n\ntype BaseConfig = AnyZodObject\ntype BaseEvent = Record<string, AnyZodObject>\ntype BaseAction = Record<string, Record<'input' | 'output', AnyZodObject>>\ntype BaseChannel = Record<string, Record<string, AnyZodObject>>\ntype BaseState = Record<string, AnyZodObject>\n\n// TODO: allow any versions\ntype IntegrationDefinitionVersion =\n  | {\n      /** Only version 0.2.0 is supported for public integrations yet. This is temporary. */\n      version: typeof PUBLIC_VERSION\n    }\n  | {\n      /** Only version 0.0.1 is supported for private integrations yet. This is temporary. */\n      version: typeof PRIVATE_VERSION\n    }\n\nexport type IntegrationDefinitionProps<\n  TConfig extends BaseConfig = BaseConfig,\n  TEvent extends BaseEvent = BaseEvent,\n  TAction extends BaseAction = BaseAction,\n  TChannel extends BaseChannel = BaseChannel,\n  TState extends BaseState = BaseState\n> = Omit<\n  IntegrationDefinitionOutput,\n  'public' | 'version' | 'configuration' | 'events' | 'actions' | 'channels' | 'states'\n> &\n  IntegrationDefinitionVersion & {\n    configuration?: Merge<ConfigurationDefinition, SchemaDefinition<TConfig>>\n    events?: { [K in keyof TEvent]: Merge<EventDefinition, SchemaDefinition<TEvent[K]>> }\n\n    actions?: {\n      [K in keyof TAction]: Merge<\n        ActionDefinition,\n        {\n          ['input']: SchemaDefinition<Cast<TAction[K]['input'], AnyZodObject>>\n          ['output']: SchemaDefinition<Cast<TAction[K]['output'], AnyZodObject>>\n        }\n      >\n    }\n\n    channels?: {\n      [K in keyof TChannel]: Merge<\n        ChannelDefinition,\n        {\n          messages: {\n            [L in keyof TChannel[K]]: Merge<MessageDefinition, SchemaDefinition<TChannel[K][L]>>\n          }\n        }\n      >\n    }\n\n    states?: {\n      [K in keyof TState]: Merge<StateDefinition, SchemaDefinition<TState[K]>>\n    }\n  }\n\nfunction formatIntegrationDefinition(\n  definition: IntegrationDefinitionProps<BaseConfig, BaseEvent, BaseAction, BaseChannel, BaseState>\n): IntegrationDefinitionInput {\n  return {\n    ...definition,\n    configuration: definition.configuration\n      ? {\n          ...definition.configuration,\n          schema: schemaDefinitionToJsonSchema(definition.configuration),\n        }\n      : undefined,\n    events: definition.events\n      ? mapValues(definition.events, (event) => ({\n          ...event,\n          schema: schemaDefinitionToJsonSchema(event),\n        }))\n      : undefined,\n    actions: definition.actions\n      ? mapValues(definition.actions, (action) => ({\n          ...action,\n          input: {\n            ...action.input,\n            schema: schemaDefinitionToJsonSchema(action.input),\n          },\n          output: {\n            ...action.output,\n            schema: schemaDefinitionToJsonSchema(action.output),\n          },\n        }))\n      : undefined,\n    channels: definition.channels\n      ? mapValues(definition.channels, (channel) => ({\n          ...channel,\n          messages: mapValues(channel.messages, (message) => ({\n            ...message,\n            schema: schemaDefinitionToJsonSchema(message),\n          })),\n        }))\n      : undefined,\n    states: definition.states\n      ? mapValues(definition.states, (state) => ({\n          ...state,\n          schema: schemaDefinitionToJsonSchema(state),\n        }))\n      : undefined,\n    user: definition.user,\n  }\n}\n\nexport class IntegrationDefinition<\n  TConfig extends BaseConfig = BaseConfig,\n  TEvent extends BaseEvent = BaseEvent,\n  TAction extends BaseAction = BaseAction,\n  TChannel extends BaseChannel = BaseChannel,\n  TState extends BaseState = BaseState\n> {\n  public readonly name: IntegrationDefinitionOutput['name']\n  public readonly version: IntegrationDefinitionOutput['version']\n  public readonly icon: IntegrationDefinitionOutput['icon']\n  public readonly readme: IntegrationDefinitionOutput['readme']\n  public readonly title: IntegrationDefinitionOutput['title']\n  public readonly description: IntegrationDefinitionOutput['description']\n  public readonly configuration: IntegrationDefinitionOutput['configuration']\n  public readonly events: IntegrationDefinitionOutput['events']\n  public readonly actions: IntegrationDefinitionOutput['actions']\n  public readonly channels: IntegrationDefinitionOutput['channels']\n  public readonly states: IntegrationDefinitionOutput['states']\n  public readonly user: IntegrationDefinitionOutput['user']\n  public readonly secrets: IntegrationDefinitionOutput['secrets']\n  public constructor(props: IntegrationDefinitionProps<TConfig, TEvent, TAction, TChannel, TState>) {\n    const integrationDefinitionInput = formatIntegrationDefinition(props)\n    const parsed = integrationDefinitionSchema.parse(integrationDefinitionInput)\n\n    const {\n      name,\n      version,\n      icon,\n      readme,\n      title,\n      description,\n      configuration,\n      events,\n      actions,\n      channels,\n      states,\n      user,\n      secrets,\n    } = parsed\n    this.name = name\n    this.version = version\n    this.icon = icon\n    this.readme = readme\n    this.title = title\n    this.description = description\n    this.configuration = configuration\n    this.events = events\n    this.actions = actions\n    this.channels = channels\n    this.states = states\n    this.user = user\n    this.secrets = secrets\n  }\n}\n", "import type { z } from 'zod'\nimport zodToJsonSchema from 'zod-to-json-schema'\nimport type { JsonSchema7Type } from 'zod-to-json-schema/src/parseDef'\nimport type { JsonSchema7ObjectType } from 'zod-to-json-schema/src/parsers/object'\n\ntype JsonSchemaPropertyType = JsonSchema7Type & { title?: string; examples?: any[] }\nconst isObjectSchema = (schema: JsonSchema7Type): schema is JsonSchema7ObjectType => {\n  return (schema as any)?.type === 'object'\n}\n\nexport type SchemaOptions<T> = {\n  title: string\n  examples: T[]\n}\n\ntype IsEmptyObject<T> = keyof T extends never ? true : false\n\nexport type UiDefinition<TSchema extends z.ZodObject<any>> = IsEmptyObject<z.infer<TSchema>> extends true\n  ? Record<string, never>\n  : {\n      [K in keyof z.infer<TSchema>]: Partial<SchemaOptions<z.infer<TSchema>[K]>>\n    }\n\nexport type SchemaDefinition<TSchema extends z.ZodObject<any>> = {\n  schema: TSchema\n  ui?: Partial<UiDefinition<TSchema>>\n}\n\nexport function schemaDefinitionToJsonSchema(\n  definition: SchemaDefinition<z.ZodObject<any>>\n): ReturnType<typeof zodToJsonSchema> {\n  const schema = zodToJsonSchema(definition.schema, { errorMessages: true })\n  if (!isObjectSchema(schema) || !definition.ui) {\n    return schema\n  }\n\n  for (const [key, value] of Object.entries(definition.ui ?? {})) {\n    const property = schema.properties?.[key] as JsonSchemaPropertyType | undefined\n\n    if (!property) {\n      continue\n    }\n\n    if (!!value?.title) {\n      property.title = value.title\n    }\n\n    if (!!value?.examples) {\n      property.examples = value.examples\n    }\n  }\n\n  return schema\n}\n", "import { Client, Conversation, Message, User, RuntimeError } from '@botpress/client'\n\nimport {\n  botIdHeader,\n  botUserIdHeader,\n  configurationHeader,\n  integrationIdHeader,\n  operationHeader,\n  webhookIdHeader,\n} from '../const'\nimport { Request, Response, serve } from '../serve'\nimport { IntegrationContext, integrationOperationSchema } from './context'\nimport type {\n  ActionPayload,\n  CreateConversationPayload,\n  CreateUserPayload,\n  IntegrationImplementationProps,\n  RegisterPayload,\n  UnregisterPayload,\n  WebhookPayload,\n} from './implementation'\nimport { IntegrationLogger, integrationLogger } from './logger'\n\ntype OperationHandlerProps = {\n  integration: IntegrationImplementationProps\n  ctx: IntegrationContext\n  req: Request\n  client: Client\n  logger: IntegrationLogger\n}\n\nexport const serveIntegration = async (integration: IntegrationImplementationProps, port = 6853) => {\n  await serve(integrationHandler(integration), port)\n}\n\nexport const integrationHandler =\n  (integration: IntegrationImplementationProps) =>\n  // eslint-disable-next-line complexity\n  async (req: Request): Promise<Response | void> => {\n    const ctx = extractContext(req.headers)\n    const client = new Client({ botId: ctx.botId, integrationId: ctx.integrationId })\n\n    const props: OperationHandlerProps = {\n      integration,\n      ctx,\n      req,\n      client,\n      logger: integrationLogger,\n    }\n\n    try {\n      let response: Response | void\n      switch (ctx.operation) {\n        case 'webhook_received':\n          response = await onWebhook(props)\n          break\n        case 'register':\n          response = await onRegister(props)\n          break\n        case 'unregister':\n          response = await onUnregister(props)\n          break\n        case 'message_created':\n          response = await onMessageCreated(props)\n          break\n        case 'action_triggered':\n          response = await onActionTriggered(props)\n          break\n        case 'ping':\n          response = await onPing(props)\n          break\n        case 'create_user':\n          response = await onCreateUser(props)\n          break\n        case 'create_conversation':\n          response = await onCreateConversation(props)\n          break\n        default:\n          throw new Error(`Unknown operation ${ctx.operation}`)\n      }\n      return response ? { ...response, status: response.status ?? 200 } : { status: 200 }\n    } catch (e) {\n      if (e instanceof RuntimeError) {\n        return { status: e.code, body: JSON.stringify(e.toJSON()) }\n      } else {\n        throw e\n      }\n    }\n  }\n\nfunction extractContext(headers: Record<string, string | undefined>): IntegrationContext {\n  const botId = headers[botIdHeader]\n  const botUserId = headers[botUserIdHeader]\n  const integrationId = headers[integrationIdHeader]\n  const webhookId = headers[webhookIdHeader]\n  const base64Configuration = headers[configurationHeader]\n  const operation = integrationOperationSchema.parse(headers[operationHeader])\n\n  if (!botId) {\n    throw new Error('Missing bot headers')\n  }\n\n  if (!botUserId) {\n    throw new Error('Missing bot user headers')\n  }\n\n  if (!integrationId) {\n    throw new Error('Missing integration headers')\n  }\n\n  if (!webhookId) {\n    throw new Error('Missing webhook headers')\n  }\n\n  if (!base64Configuration) {\n    throw new Error('Missing configuration headers')\n  }\n\n  if (!operation) {\n    throw new Error('Missing operation headers')\n  }\n\n  return {\n    botId,\n    botUserId,\n    integrationId,\n    webhookId,\n    operation,\n    configuration: base64Configuration ? JSON.parse(Buffer.from(base64Configuration, 'base64').toString('utf-8')) : {},\n  }\n}\n\nfunction parseBody<T>(req: Request): T {\n  if (!req.body) {\n    throw new Error('Missing body')\n  }\n\n  return JSON.parse(req.body)\n}\n\n// TODO implement the ping operation once the signature is defined\nasync function onPing(_: OperationHandlerProps) {}\n\nasync function onWebhook({ client, ctx, integration, req: incomingRequest, logger }: OperationHandlerProps) {\n  const { req } = parseBody<WebhookPayload>(incomingRequest)\n  return integration.handler({ client, ctx, req, logger })\n}\n\nasync function onRegister({ client, ctx, integration, req, logger }: OperationHandlerProps) {\n  if (!integration.register) {\n    return\n  }\n\n  const { webhookUrl } = parseBody<RegisterPayload>(req)\n\n  await integration.register({ client, ctx, webhookUrl, logger })\n}\n\nasync function onUnregister({ client, ctx, integration, req, logger }: OperationHandlerProps) {\n  if (!integration.unregister) {\n    return\n  }\n\n  const { webhookUrl } = parseBody<UnregisterPayload>(req)\n\n  await integration.unregister({ ctx, webhookUrl, client, logger })\n}\n\nasync function onCreateUser({ client, ctx, integration, req, logger }: OperationHandlerProps) {\n  if (!integration.createUser) {\n    return\n  }\n\n  const { tags } = parseBody<CreateUserPayload>(req)\n\n  return await integration.createUser({ ctx, client, tags, logger })\n}\n\nasync function onCreateConversation({ client, ctx, integration, req, logger }: OperationHandlerProps) {\n  if (!integration.createConversation) {\n    return\n  }\n\n  const { channel, tags } = parseBody<CreateConversationPayload>(req)\n\n  return await integration.createConversation({ ctx, client, channel, tags, logger })\n}\n\nexport type MessageCreatedPayload = {\n  conversation: Conversation\n  user: User\n  message: Message\n  payload: any\n  type: string\n}\n\nasync function onMessageCreated({ ctx, integration, req, client, logger }: OperationHandlerProps) {\n  const { conversation, user, type, payload, message } = parseBody<MessageCreatedPayload>(req)\n\n  const channelHandler = integration.channels[conversation.channel]\n\n  if (!channelHandler) {\n    throw new Error(`Channel ${conversation.channel} not found`)\n  }\n\n  const messageHandler = channelHandler.messages[type]\n\n  if (!messageHandler) {\n    throw new Error(`Message of type ${type} not found in channel ${conversation.channel}`)\n  }\n\n  const ack = async ({ tags }: { tags: { [key: string]: string } }) => {\n    await client.updateMessage({\n      id: message.id,\n      tags,\n    })\n  }\n\n  await messageHandler({ ctx, conversation, message, user, type, client, payload, ack, logger })\n}\n\nasync function onActionTriggered({ req, integration, ctx, client, logger }: OperationHandlerProps) {\n  const { input, type } = parseBody<ActionPayload<string, any>>(req)\n\n  if (!type) {\n    throw new Error('Missing action type')\n  }\n\n  const action = integration.actions[type]\n\n  if (!action) {\n    throw new Error(`Action ${type} not found`)\n  }\n\n  const output = await action({ ctx, input, client, type, logger })\n\n  return {\n    body: JSON.stringify({ output }),\n  }\n}\n", "/* eslint-disable no-console */\nimport util from 'util'\n\nconst serializeForBotMessage = (args: Parameters<typeof util.format>) => {\n  if (process.env['BP_LOG_FORMAT'] === 'json') {\n    return JSON.stringify({ msg: util.format(...args), visible_to_bot_owner: true })\n  } else {\n    const [format, ...param] = args\n    return util.format(`[For Bot Owner] ${format}`, ...param)\n  }\n}\n\nexport const integrationLogger = {\n  /**\n   * Use this function to log messages that will be displayed to the Bot Owner.\n   */\n  forBot: () => {\n    return {\n      info: (...args: Parameters<typeof console.info>) => {\n        console.info(serializeForBotMessage(args))\n      },\n      warn: (...args: Parameters<typeof console.warn>) => {\n        console.warn(serializeForBotMessage(args))\n      },\n      error: (...args: Parameters<typeof console.error>) => {\n        console.error(serializeForBotMessage(args))\n      },\n      debug: (...args: Parameters<typeof console.debug>) => {\n        console.debug(serializeForBotMessage(args))\n      },\n    }\n  },\n}\n\nexport type IntegrationLogger = typeof integrationLogger\n", "import type { Client, Conversation, Message, User } from '@botpress/client'\nimport type { Server } from 'node:http'\nimport { Request, Response, serve } from '../serve'\nimport type { IntegrationContext } from './context'\nimport { IntegrationLogger } from './logger'\nimport { integrationHandler } from './server'\n\ntype IntegrationProps<Configuration> = {\n  ctx: IntegrationContext<Configuration>\n  client: Client\n  logger: IntegrationLogger\n}\n\nexport type RegisterPayload = {\n  webhookUrl: string\n}\n\nexport type UnregisterPayload = {\n  webhookUrl: string\n}\n\nexport type WebhookPayload = {\n  req: Request\n}\n\nexport type ActionPayload<T, I> = {\n  type: T\n  input: I\n}\n\nexport type EventPayload<E> = {\n  event: E\n}\n\nexport type CreateUserPayload = {\n  tags: Tags\n}\n\nexport type CreateConversationPayload = {\n  channel: string\n  tags: Tags\n}\n\ntype Tags = { [key: string]: string }\n\nexport type AckFunction = (props: { tags: Tags }) => Promise<void>\n\nexport type MessagePayload<P, M, C, U> = {\n  payload: P\n  conversation: C\n  message: M\n  user: U\n  type: string\n}\n\nexport type ActionDefinitions = {\n  [actionType: string]: {\n    input: any\n    output: any\n  }\n}\n\nexport type ChannelDefinitions = {\n  [channelName: string]: MessageDefinitions\n}\n\nexport type EventDefinitions = {\n  [eventName: string]: any\n}\n\ntype MessageDefinitions = {\n  [messageType: string]: any\n}\n\ntype ActionFunctions<Configuration, A extends ActionDefinitions> = {\n  [actionType in keyof A]: (\n    props: IntegrationProps<Configuration> & ActionPayload<actionType, A[actionType]['input']>\n  ) => Promise<A[actionType]['output']>\n}\n\ntype MessageHandlerProps = {\n  ack: AckFunction\n}\n\nexport type ChannelFunctions<Configuration, C extends ChannelDefinitions> = {\n  [channelName in keyof C]: {\n    messages: {\n      [messageType in keyof C[channelName]]: (\n        props: IntegrationProps<Configuration> &\n          MessagePayload<C[channelName][messageType], Message, Conversation, User> &\n          MessageHandlerProps\n      ) => Promise<void>\n    }\n  }\n}\n\ntype BaseConfig = any\ntype BaseActions = ActionDefinitions\ntype BaseChannels = ChannelDefinitions\ntype BaseEvents = EventDefinitions\n\nexport type IntegrationImplementationProps<\n  Configuration extends any = BaseConfig,\n  Actions extends ActionDefinitions = BaseActions,\n  Channels extends ChannelDefinitions = BaseChannels,\n  _Events extends EventDefinitions = BaseEvents\n> = {\n  register: (props: IntegrationProps<Configuration> & RegisterPayload) => Promise<void>\n  unregister: (props: IntegrationProps<Configuration> & UnregisterPayload) => Promise<void>\n  handler: (props: IntegrationProps<Configuration> & WebhookPayload) => Promise<Response | void>\n  createUser?: (props: IntegrationProps<Configuration> & CreateUserPayload) => Promise<Response | void>\n  createConversation?: (props: IntegrationProps<Configuration> & CreateConversationPayload) => Promise<Response | void>\n  actions: ActionFunctions<Configuration, Actions>\n  channels: ChannelFunctions<Configuration, Channels>\n}\n\nexport class IntegrationImplementation<\n  Configuration extends any = BaseConfig,\n  Actions extends ActionDefinitions = BaseActions,\n  Channels extends ChannelDefinitions = BaseChannels,\n  Events extends EventDefinitions = BaseEvents\n> {\n  public readonly props: IntegrationImplementationProps<Configuration, Actions, Channels, Events>\n  public readonly actions: IntegrationImplementationProps<Configuration, Actions, Channels, Events>['actions']\n  public readonly channels: IntegrationImplementationProps<Configuration, Actions, Channels, Events>['channels']\n  public readonly register: IntegrationImplementationProps<Configuration, Actions, Channels, Events>['register']\n  public readonly unregister: IntegrationImplementationProps<Configuration, Actions, Channels, Events>['unregister']\n  public readonly createUser: IntegrationImplementationProps<Configuration, Actions, Channels, Events>['createUser']\n  public readonly createConversation: IntegrationImplementationProps<\n    Configuration,\n    Actions,\n    Channels,\n    Events\n  >['createConversation']\n  public readonly handler: ReturnType<typeof integrationHandler>\n  public readonly start: (port?: number) => Promise<Server>\n\n  public constructor(props: IntegrationImplementationProps<Configuration, Actions, Channels, Events>) {\n    this.props = props\n    this.actions = props.actions\n    this.channels = props.channels\n    this.register = props.register\n    this.unregister = props.unregister\n    this.createUser = props.createUser\n    this.createConversation = props.createConversation\n    this.handler = integrationHandler(props as IntegrationImplementationProps)\n    this.start = (port?: number) => serve(this.handler, port)\n  }\n}\n", "import { z } from 'zod'\n\nconst NonEmptyString = z.string().min(1)\n\nconst textMessageSchema = z.object({\n  text: NonEmptyString,\n})\n\nconst markdownMessageSchema = z.object({\n  markdown: NonEmptyString,\n})\n\nconst imageMessageSchema = z.object({\n  imageUrl: NonEmptyString,\n})\n\nconst audioMessageSchema = z.object({\n  audioUrl: NonEmptyString,\n})\n\nconst videoMessageSchema = z.object({\n  videoUrl: NonEmptyString,\n})\n\nconst fileMessageSchema = z.object({\n  fileUrl: NonEmptyString,\n  title: NonEmptyString.optional(),\n})\n\nconst locationMessageSchema = z.object({\n  latitude: z.number(),\n  longitude: z.number(),\n  address: z.string().optional(),\n  title: z.string().optional(),\n})\n\nconst cardSchema = z.object({\n  title: NonEmptyString,\n  subtitle: NonEmptyString.optional(),\n  imageUrl: NonEmptyString.optional(),\n  actions: z.array(\n    z.object({\n      action: z.enum(['postback', 'url', 'say']),\n      label: NonEmptyString,\n      value: NonEmptyString,\n    })\n  ),\n})\n\nconst choiceSchema = z.object({\n  text: NonEmptyString,\n  options: z.array(\n    z.object({\n      label: NonEmptyString,\n      value: NonEmptyString,\n    })\n  ),\n})\n\nconst carouselSchema = z.object({\n  items: z.array(cardSchema),\n})\n\nexport const defaults = {\n  text: { schema: textMessageSchema },\n  markdown: { schema: markdownMessageSchema },\n  image: { schema: imageMessageSchema },\n  audio: { schema: audioMessageSchema },\n  video: { schema: videoMessageSchema },\n  file: { schema: fileMessageSchema },\n  location: { schema: locationMessageSchema },\n  carousel: { schema: carouselSchema },\n  card: { schema: cardSchema },\n  dropdown: { schema: choiceSchema },\n  choice: { schema: choiceSchema },\n} as const // should use satisfies operator but this works for older versions of TS\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "Bot", "IntegrationImplementation", "IntegrationDefinition", "botIdHeader", "botUserIdHeader", "clients", "configurationHeader", "integrationIdHeader", "message_exports", "operationHeader", "serve", "typeHeader", "webhookIdHeader", "__toCommonJS", "import_axios", "botIdHeader", "botUserIdHeader", "integrationIdHeader", "webhookIdHeader", "configurationHeader", "operationHeader", "typeHeader", "BotClient", "axiosInstance", "axiosGlobal", "props", "request", "formatBotHeaders", "ctx", "typeHeader", "botIdHeader", "operationHeader", "configurationHeader", "operation", "url", "data", "axios", "import_node_http", "log", "serve", "handler", "port", "callback", "defaultCallback", "server", "req", "res", "request", "mapIncomingMessageToRequest", "response", "e", "log", "incoming", "body", "readBody", "headers", "i", "key", "value", "url", "trimPrefix", "prefix", "resolve", "reject", "chunk", "import_client", "import_zod", "botOperationSchema", "createBotHandler", "botState", "req", "ctx", "extractContext", "log", "client", "props", "onEventReceived", "onRegister", "onUnregister", "onPing", "headers", "botId", "botIdHeader", "base64Configuration", "configurationHeader", "type", "typeHeader", "operation", "botOperationSchema", "operationHeader", "body", "parseBody", "handler", "_", "Bot", "def", "handler", "createBotHandler", "port", "serve", "import_client", "import_axios", "import_client", "import_zod", "e", "runtimeErrorSchema", "IntegrationClient", "axiosInstance", "axiosGlobal", "props", "request", "webhookRequest", "formatIntegrationHeaders", "ctx", "botIdHeader", "operationHeader", "botUserIdHeader", "integrationIdHeader", "webhookIdHeader", "configurationHeader", "operation", "url", "data", "axios", "e", "runtimeErrorCode", "result", "runtimeErrorSchema", "import_zod", "integrationOperationSchema", "import_radash", "import_zod", "import_zod_to_json_schema", "isObjectSchema", "schema", "schemaDefinitionToJsonSchema", "definition", "zodToJsonSchema", "key", "value", "property", "nonEmptyDict", "v", "r", "obj", "schemaSchema", "configurationDefinitionSchema", "eventDefinitionSchema", "actionDefinitionSchema", "messageDefinitionSchema", "tagDefinitionSchema", "channelDefinitionSchema", "stateDefinitionSchema", "PUBLIC_VERSION", "PRIVATE_VERSION", "integrationDefinitionSchema", "formatIntegrationDefinition", "definition", "schemaDefinitionToJsonSchema", "event", "action", "channel", "message", "state", "IntegrationDefinition", "props", "integrationDefinitionInput", "parsed", "name", "version", "icon", "readme", "title", "description", "configuration", "events", "actions", "channels", "states", "user", "secrets", "import_client", "import_util", "serializeForBotMessage", "args", "util", "format", "param", "integrationLogger", "integrationHandler", "integration", "req", "ctx", "extractContext", "client", "props", "integrationLogger", "response", "onWebhook", "onRegister", "onUnregister", "onMessageCreated", "onActionTriggered", "onPing", "onCreateUser", "onCreateConversation", "e", "headers", "botId", "botIdHeader", "botUserId", "botUserIdHeader", "integrationId", "integrationIdHeader", "webhookId", "webhookIdHeader", "base64Configuration", "configurationHeader", "operation", "integrationOperationSchema", "operationHeader", "parseBody", "_", "incomingRequest", "logger", "webhookUrl", "tags", "channel", "conversation", "user", "type", "payload", "message", "channelHandler", "messageHandler", "input", "action", "output", "IntegrationImplementation", "props", "integrationHandler", "port", "serve", "message_exports", "__export", "defaults", "import_zod", "NonEmptyString", "textMessageSchema", "markdownMessageSchema", "imageMessageSchema", "audioMessageSchema", "videoMessageSchema", "fileMessageSchema", "locationMessageSchema", "cardSchema", "choiceSchema", "carouselSchema", "clients", "IntegrationClient", "BotClient"]
}
